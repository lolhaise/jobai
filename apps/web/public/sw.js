// Service worker for JobAI PWA\n// This file is the compiled JavaScript version that runs in the browser\n\n// Service worker version for cache management\nconst CACHE_VERSION = 'v1.0.0'\nconst STATIC_CACHE = `jobai-static-${CACHE_VERSION}`\nconst DYNAMIC_CACHE = `jobai-dynamic-${CACHE_VERSION}`\nconst API_CACHE = `jobai-api-${CACHE_VERSION}`\nconst IMAGE_CACHE = `jobai-images-${CACHE_VERSION}`\n\n// Maximum cache sizes to prevent storage bloat\nconst MAX_DYNAMIC_SIZE = 50\nconst MAX_API_SIZE = 100\nconst MAX_IMAGE_SIZE = 60\n\n// Static assets to cache immediately on install\nconst STATIC_ASSETS = [\n  '/',\n  '/dashboard',\n  '/jobs',\n  '/applications',\n  '/resume',\n  '/offline',\n  '/manifest.json'\n]\n\n// Install event - cache static assets\nself.addEventListener('install', event => {\n  console.log('[SW] Installing service worker...')\n  \n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => {\n        console.log('[SW] Caching static assets')\n        return cache.addAll(STATIC_ASSETS)\n      })\n      .then(() => {\n        console.log('[SW] Static assets cached')\n        return self.skipWaiting()\n      })\n      .catch(err => {\n        console.error('[SW] Failed to cache static assets:', err)\n      })\n  )\n})\n\n// Activate event - clean up old caches\nself.addEventListener('activate', event => {\n  console.log('[SW] Activating service worker...')\n  \n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames\n            .filter(cacheName => !cacheName.includes(CACHE_VERSION))\n            .map(cacheName => {\n              console.log('[SW] Deleting old cache:', cacheName)\n              return caches.delete(cacheName)\n            })\n        )\n      })\n      .then(() => {\n        console.log('[SW] Service worker activated')\n        return self.clients.claim()\n      })\n      .catch(err => {\n        console.error('[SW] Failed to activate:', err)\n      })\n  )\n})\n\n// Fetch event - handle all network requests\nself.addEventListener('fetch', event => {\n  const { request } = event\n  const url = new URL(request.url)\n  \n  // Skip non-GET requests and chrome-extension requests\n  if (request.method !== 'GET' || url.protocol === 'chrome-extension:') {\n    return\n  }\n  \n  // Handle different request types with appropriate strategies\n  if (isStaticAsset(url)) {\n    event.respondWith(cacheFirstStrategy(request, STATIC_CACHE))\n  } else if (isApiRequest(url)) {\n    event.respondWith(networkFirstStrategy(request, API_CACHE))\n  } else if (isImageRequest(url)) {\n    event.respondWith(cacheFirstStrategy(request, IMAGE_CACHE))\n  } else if (isPageRequest(url)) {\n    event.respondWith(networkFirstWithFallback(request))\n  } else {\n    event.respondWith(networkFirstStrategy(request, DYNAMIC_CACHE))\n  }\n})\n\n// Background sync event\nself.addEventListener('sync', event => {\n  console.log('[SW] Background sync:', event.tag)\n  \n  if (event.tag === 'job-applications-sync') {\n    event.waitUntil(syncJobApplications())\n  }\n})\n\n// Push notification event\nself.addEventListener('push', event => {\n  console.log('[SW] Push notification received')\n  \n  let notificationData = {\n    title: 'JobAI',\n    body: 'You have a new notification',\n    icon: '/icons/icon-192x192.png',\n    badge: '/icons/badge-72x72.png',\n    vibrate: [200, 100, 200],\n    data: { url: '/dashboard' }\n  }\n  \n  if (event.data) {\n    try {\n      notificationData = { ...notificationData, ...event.data.json() }\n    } catch (err) {\n      console.error('[SW] Failed to parse push data:', err)\n    }\n  }\n  \n  event.waitUntil(\n    self.registration.showNotification(notificationData.title, notificationData)\n  )\n})\n\n// Notification click event\nself.addEventListener('notificationclick', event => {\n  console.log('[SW] Notification clicked')\n  \n  event.notification.close()\n  \n  const urlToOpen = event.notification.data?.url || '/dashboard'\n  \n  event.waitUntil(\n    self.clients.matchAll({ type: 'window', includeUncontrolled: true })\n      .then(clients => {\n        // Focus existing window if available\n        for (const client of clients) {\n          if (client.url.includes(urlToOpen) && 'focus' in client) {\n            return client.focus()\n          }\n        }\n        \n        // Open new window\n        if (self.clients.openWindow) {\n          return self.clients.openWindow(urlToOpen)\n        }\n      })\n  )\n})\n\n// Helper functions\nfunction isStaticAsset(url) {\n  return url.pathname.startsWith('/_next/static/') ||\n         url.pathname.startsWith('/icons/') ||\n         url.pathname.endsWith('.js') ||\n         url.pathname.endsWith('.css') ||\n         url.pathname === '/manifest.json'\n}\n\nfunction isApiRequest(url) {\n  return url.pathname.startsWith('/api/')\n}\n\nfunction isImageRequest(url) {\n  return /\\.(png|jpg|jpeg|webp|svg|ico)$/i.test(url.pathname)\n}\n\nfunction isPageRequest(url) {\n  return url.origin === self.location.origin &&\n         !isStaticAsset(url) &&\n         !isApiRequest(url) &&\n         !isImageRequest(url)\n}\n\n// Caching strategies\nfunction cacheFirstStrategy(request, cacheName) {\n  return caches.open(cacheName)\n    .then(cache => cache.match(request))\n    .then(cachedResponse => {\n      if (cachedResponse) {\n        console.log('[SW] Serving from cache:', request.url)\n        return cachedResponse\n      }\n      \n      return fetch(request)\n        .then(networkResponse => {\n          if (networkResponse.ok) {\n            cache.put(request, networkResponse.clone())\n          }\n          return networkResponse\n        })\n    })\n    .catch(err => {\n      console.error('[SW] Cache first failed:', err)\n      throw err\n    })\n}\n\nfunction networkFirstStrategy(request, cacheName) {\n  return caches.open(cacheName)\n    .then(cache => {\n      return fetch(request)\n        .then(networkResponse => {\n          if (networkResponse.ok) {\n            cache.put(request, networkResponse.clone())\n            limitCacheSize(cache, getMaxCacheSize(cacheName))\n          }\n          return networkResponse\n        })\n        .catch(err => {\n          console.log('[SW] Network failed, trying cache:', request.url)\n          return cache.match(request)\n            .then(cachedResponse => {\n              if (cachedResponse) {\n                return cachedResponse\n              }\n              throw err\n            })\n        })\n    })\n}\n\nfunction networkFirstWithFallback(request) {\n  return networkFirstStrategy(request, DYNAMIC_CACHE)\n    .catch(err => {\n      console.log('[SW] Serving offline page')\n      return caches.match('/offline')\n    })\n}\n\nfunction getMaxCacheSize(cacheName) {\n  if (cacheName.includes('dynamic')) return MAX_DYNAMIC_SIZE\n  if (cacheName.includes('api')) return MAX_API_SIZE\n  if (cacheName.includes('images')) return MAX_IMAGE_SIZE\n  return 30\n}\n\nfunction limitCacheSize(cache, maxSize) {\n  cache.keys()\n    .then(keys => {\n      if (keys.length > maxSize) {\n        const deletePromises = keys.slice(0, keys.length - maxSize)\n          .map(key => cache.delete(key))\n        return Promise.all(deletePromises)\n      }\n    })\n    .then(() => {\n      console.log('[SW] Cache size limited')\n    })\n    .catch(err => {\n      console.error('[SW] Failed to limit cache size:', err)\n    })\n}\n\nfunction syncJobApplications() {\n  console.log('[SW] Syncing job applications...')\n  // Implement sync logic here\n  return Promise.resolve()\n}